require 'puppet/util/ptomulik/packagex'
require 'fileutils'

module Puppet::Util::PTomulik::Packagex::Portsx

  class Options

    # Module from ptomulik/vash puppet plugin
    require 'puppet/util/ptomulik/vash/contained'
    include Puppet::Util::PTomulik::Vash::Contained

    # Is x valid as option name?
    def self.option_name?(x)
      x = x.to_s if x.is_a?(Symbol)
      x.is_a?(String) and x =~ /^[a-zA-Z_]\w*$/
    end

    # Is x valid as option value?
    def self.option_value?(x)
      ['on', 'off', :on, :off, true, false].include?(x)
    end

    # Convert valid option names to symbols
    def self.munge_option_name(name)
      # note, on 1.8 Symbol has no :intern method
      name.is_a?(String) ? name.intern : name
    end

    # Convert valid option values (strings, symbols) to boolean values
    def self.munge_option_value(value)
      case value
      when 'on', :on, true; true
      else; false
      end
    end

    # --
    # Overriden methods from Vash::Contained
    # ++
    def vash_valid_key?(x);     self.class.option_name?(x);          end
    def vash_valid_value?(x);   self.class.option_value?(x);         end
    def vash_munge_key(key);    self.class.munge_option_name(key);   end
    def vash_munge_value(val);  self.class.munge_option_value(val);  end
    def vash_key_name(*args);   'option name';                       end
    def vash_value_exception(val,*args)
      name = vash_value_name(val,*args)
      msg  = "invalid value #{val.inspect}"
      msg += " at position  #{args[0].inspect}" unless args[0].nil?
      msg += " for option #{args[1].to_s}" unless args.length < 2
      [Puppet::Util::PTomulik::Vash::InvalidValueError, msg]
    end


    # Parse string for options. The `string` is a content of options file.
    def self.parse(string)
      opt_re = /^\s*OPTIONS_FILE_((?:UN)?SET)\s*\+=(\w+)\s*$/
      Options[ string.scan(opt_re).map{|pair| [pair[1], pair[0]=='SET']} ]
    end

    # Read options from options files.
    #
    # @note Missing files from `files` list are ignored by default.
    def self.load(files,params={})
      files = [files] unless files.is_a?(Array)
      # concatenate all files in order ...
      contents = []
      files.each do|file|
        next if (not File.exists?(file)) and not params[:all]
        msg = "Reading port options from '#{file}'"
        respond_to?(:debug) ? debug(msg) : Puppet.debug(msg)
        contents << File.read(file)
      end
      parse(contents.join("\n"))
    end

    # Generate content of options file.
    def generate(params)
      content  = "# This file is auto-generated by puppet\n"
      if params[:pkgname]
        content += "# Options for #{params[:pkgname]}\n"
        content += "_OPTIONS_READ=#{params[:pkgname]}\n"
      end
      keys.sort.each do |k|
        v = self[k]
        content += "OPTIONS_FILE_#{v ? '':'UN'}SET+=#{k}\n"
      end
      content
    end

    # Save package options to options file.
    #
    # @param [String] file path to options' file.
    # @param [Hash] params additional parameters to function
    #
    # @option params pkgname package name to which the options apply
    # @option params mkdir_p create directory recursively if don't exist, if
    #         `false`, only last level subdirectory is allowed to be created
    #
    # @note by default we do not allow to create directories recursivelly;
    #       we assume, that '/var/db/ports' already exists and user saves
    #       its options to '/var/db/ports/my_port/options';
    def save(file,params={})
      dir = File.dirname(file)
      if not File.exists?(dir)
        msg = "Creating directory #{dir}"
        respond_to?(:debug) ? debug(msg) : Puppet.debug(msg)
        params[:mkdir_p] ?  FileUtils.mkdir_p(dir) : Dir.mkdir(dir)
      end
      msg = params[:pkgname] ?
        "Saving options for '#{params[:pkgname]}' port to file '#{file}'" :
        "Saving port options to file '#{file}'"
      respond_to?(:debug) ? debug(msg) : Puppet.debug(msg)
      File.write(file,generate(params))
    end

  end
end
